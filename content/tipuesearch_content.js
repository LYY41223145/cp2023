var tipuesearch = {"pages": [{'title': 'First', 'text': '', 'tags': '', 'url': 'First.html'}, {'title': 'C_ex', 'text': 'C的浮點數 \n #include <stdio.h>\nvoid main()\n{\nfloat a = 0.5;\ndouble b = 1.2;\nint c = 3;\nb = b + a + c;\n/* 輸出 a, b, c 到螢幕 */\nprintf( " a = %3.1f, b = %3.1f, c = %d ", a ,b, c );\n} \n \n 執行結果 a=0.5,b=4.7,c=3 \n 算術運算元\xa0 \n #include<stdio.h>\nint main()\n{\nint a,b;\na = 10; b = 3;\nprintf( "%d \\n", a * b );\nprintf( "%d \\n", a / b );\nprintf( "%d \\n", a + b );\nprintf( "%d \\n", a - b );\nprintf( "%d \\n", a % b );\nreturn 0;\n} \n 執行結果 30/3/13/7/1 \n 關係運算元 \n #include <stdio.h>\nint main()\n{\nint a = 10, b = 5;\nprintf( " a == b is %d \\n", a == b );\nprintf( " a > b is %d \\n", a > b );\nprintf( " a < b is %d \\n", a < b );\nprintf( " a >= b is %d \\n", a >= b );\nprintf( " a <= b is %d \\n", a <= b );\nprintf( " a != b is %d \\n", a != b );\nprintf( "\\n" );\nb = 10;\nprintf( " a == b is %d \\n", a == b );\nprintf( " a > b is %d \\n", a > b );\nprintf( " a < b is %d \\n", a < b );\nprintf( " a >= b is %d \\n", a >= b );\nprintf( " a <= b is %d \\n", a <= b );\nprintf( " a != b is %d \\n", a != b );\nreturn 0;\n} \n 執行結果\xa0 \n a == b is 0   a > b is 1   a < b is 0   a >= b is 1   a <= b is 0   a != b is 1 \n a == b is 1   a > b is 0   a < b is 0   a >= b is 1   a <= b is 1   a != b is 0 \n 位元運算元 \n #include<stdio.h>\nvoid main()\n{\nint a,b;\na = 15;\nb = 1;\nprintf("%d \\n", a | b ); /* a OR b */\nprintf("%d \\n", a & b ); /* a AND b */\nprintf("%d \\n", a ^ b ); /* a XOR b */\nprintf("%d \\n", a << 1 ); /* a 位元左移 1 位 */\nprintf("%d \\n", a >> 1 ); /* a 位元右移一位 */\nprintf("%d \\n", ~a ); /* A 的補數運算 */\n} \n 執行結果\xa0\xa015/1/14/30/7/-16 \n C的陣列 \n #include <stdio.h>\nint main()\n{\nint grade[5]; /* size = 5 的 array */\nint i;\ngrade[0] = 75; /* 1st element */\ngrade[1] = 80; /* 2nd element */\ngrade[2] = 85; /* 3rd element */\ngrade[3] = 70; /* 4th element */\ngrade[4] = 90; /* 5th element */\nfor( i = 0; i < 5; i ++ )\n{\nprintf("Number %d = %d\\n", i, grade[ i ] );\n}\nreturn 0;\n}\n \n \n 執行結果\xa0 \n Number 0 = 75 Number 1 = 80 Number 2 = 85 Number 3 = 70 Number 4 = 90 \n \n \n \n \n \n \n \n \n \n \n \n \n \xa0 \n \n \n \n \n \n \n \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n', 'tags': '', 'url': 'C_ex.html'}, {'title': 'W5', 'text': '\n \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W6-W7', 'text': '\n \n // 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \n \n \n // https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China\n// 內政部國旗參考資料: https://www.moi.gov.tw/cp.aspx?n=10621\n// cc roc_flag_in_gd.c -lgd -lm to link with gd and math library\n// https://www.rapidtables.com/web/color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width*2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("./../images/roc_flag_in_gd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n    // 由於中央白日圓形的半徑為青天寬度的 1/8\n    // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8\n    // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8\n    int sun_radius = (int)(width/8);\n    // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑\n    int white_circle_dia = sun_radius;\n    // 中央藍色圓形半徑為中央白日的 1又 2/15\n    int blue_circle_dia = white_circle_dia +  white_circle_dia*2/15;\n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n    // 根據畫布大小塗上紅色長方形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    // 青天面積為整面國旗的 1/4, 也是採用長方形塗色\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n    // 先設法以填色畫出六個白色堆疊菱形\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n    // 利用一個藍色大圓與白色小圓畫出藍色環狀\n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n    gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    // M_PI 大小定義於 math.h 標頭檔中, 因為三角函數中採用徑度為角度單位\n    // 因此定義將角度轉為徑度的轉換變數為 deg, 角度值乘上 deg 就可轉為徑度\n    float deg = M_PI/180;\n    // 根據十二道光芒的每一尖角的角度為 15 度, 求出其對應直角三角形的另一角度為 75 度\n    // 求出十二道光芒中任一菱形的 small radius, 也就是菱形的另一個對應小圓的半徑大小\n    float sr = sun_radius/tan(75*deg);\n    int ax, ay, bx, by, dx, dy, ex, ey;\n    gdPoint points[4];\n    /* 在塗上十二道光芒中的單一菱形區域之前, 先以座標點畫線測試是否正確\n    ax = center_x;\n    ay = center_y - sun_radius;\n    bx = center_x - sun_radius*tan(15*deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius*tan(15*deg);\n    dy = center_y;\n    // AB\n    gdImageLine(img, ax, ay, bx, by, color);\n    // BE\n    gdImageLine(img, bx, by, ex, ey, color);\n    // ED\n    gdImageLine(img, ex, ey, dx, dy, color);\n    // DA\n    gdImageLine(img, dx, dy, ax, ay, color);\n    */\n    ax = center_x;\n    ay = center_y - sun_radius;\n    bx = center_x - sun_radius*tan(15*deg);\n    by = center_y;\n    ex = center_x;\n    ey = center_y + sun_radius;\n    dx = center_x + sun_radius*tan(15*deg);\n    dy = center_y;\n    // 確定單一菱形區域的塗色正確後, 利用迴圈每次轉動 30 度, 總共轉六次即可塗上十二道光芒區域\n    for (int i=1;i<=6;i++){\n    // A\n    points[0].x = ax+sun_radius*sin(30*deg*i);\n    points[0].y = ay+sun_radius-sun_radius*cos(30*deg*i);\n    // B\n    points[1].x = bx+sr-sr*cos(30*deg*i);\n    points[1].y = by-sr*sin(30*deg*i);\n    // E\n    points[2].x = ex-sun_radius*sin(30*deg*i);\n    points[2].y = ey-(sun_radius-sun_radius*cos(30*deg*i));\n    // D\n    points[3].x = dx-(sr-sr*cos(30*deg*i));\n    points[3].y = dy+sr*sin(30*deg*i);\n    // 對菱形區域範圍塗色\n    gdImageFilledPolygon(img, points, 4, color);\n    // 在菱形區域外圍畫線, 明確界定菱形範圍\n    gdImagePolygon(img, points, 4, color);\n    }\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n \nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_usa_flag(img);\n \n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n \n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n \n    return 0;\n}\n \nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n \n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n \n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n \n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n \n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n \n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n \n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n \n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n \n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n \n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n \n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n \n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n}\n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_japan_flag(gdImagePtr img);\nvoid draw_red_sun(gdImagePtr img, int x, int y, int size, int color);\n \nint main() {\n    int originalWidth = 1200;\n    int originalHeight = (int)(originalWidth * 2.0 / 3.0);\n    gdImagePtr img = gdImageCreateTrueColor(originalWidth, originalHeight);\n    gdImageAlphaBlending(img, 0);\n \n    draw_japan_flag(img);\n \n    // 新的宽度和高度以适应 "images" 文件夹\n    int newWidth = 600;\n    int newHeight = (int)(newWidth * 2.0 / 3.0);\n \n    // 创建新图像并进行缩放\n    gdImagePtr resizedImage = gdImageCreateTrueColor(newWidth, newHeight);\n    gdImageAlphaBlending(resizedImage, 0);\n    gdImageCopyResampled(resizedImage, img, 0, 0, 0, 0, newWidth, newHeight, originalWidth, originalHeight);\n \n  FILE *outputFile = fopen("./../images/japan_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePng(resizedImage, outputFile);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    gdImageDestroy(resizedImage);\n \n    return 0;\n}\n \nvoid draw_japan_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n \n    // 创建一个白色背景\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n    gdImageFilledRectangle(img, 0, 0, width - 1, height - 1, white);\n \n    // 绘制红色圆圈（太阳）\n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int center_x = width / 2;\n    int center_y = height / 2;\n    int radius = (int)((width * 2) / 3);\n    draw_red_sun(img, center_x, center_y, radius, red);\n}\n \nvoid draw_red_sun(gdImagePtr img, int x, int y, int size, int color) {\n  // 減小 size 的值,例如將他的值減半\n  size = size / 2;\n    gdImageArc(img, x, y, size, size, 0, 360, color);\n    gdImageFillToBorder(img, x, y, color, color);\n} \n \n', 'tags': '', 'url': 'W6-W7.html'}, {'title': 'W12', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nint main() {\n    int width = 800;\n    int height = 600;\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    FILE *outputFile = fopen("hellogd.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    \n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n    // 長方形塗色\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, blue);\n    // 橢圓形塗色\n    gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);\n    // 橢圓形畫線\n    gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);\n    // 畫直線\n    gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue);\n    \n    // 多邊形畫線\n    gdPoint points[4];\n    points[0].x = (int)width/4;\n    points[0].y = (int)height*3/4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n    gdImagePolygon(img, points, 4, black);\n    \n    // 多邊形塗色\n    gdPoint points2[4];\n    points2[0].x = (int)width/3;\n    points2[0].y = (int)height/2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n    gdImageFilledPolygon(img, points2, 4, red);\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n} \n \n', 'tags': '', 'url': 'W12.html'}, {'title': 'W13', 'text': '這堂課讓我認知到對於電腦的應用還有軟體的使用在未來工作上有極大的幫助， \n 雖然這堂課對於我來說有些許的困難度，但我還是積極地觀看老師影片跟著做， \n 對於不懂的問題也虛心地向同學請教，當然不會的事情還有許多許多，我依然會積極地去改進。 \n', 'tags': '', 'url': 'W13.html'}, {'title': 'W14', 'text': '// https://en.wikipedia.org/wiki/Flag_of_South_Korea\n// https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Function prototype\nvoid draw_korean_flag(gdImagePtr img);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 72:48 = 12:8 = 3:2\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_korean_flag(img);\n\n    FILE *outputFile = fopen("korean_flag_in_gd_w15_step1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_korean_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, blue, black, grey, white;\n    // according to https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n    double scale = width/72;\n    int big_circle_dia = (int)24*scale;\n    int small_circle_dia = (int) big_circle_dia/2;\n    double rot_ang = atan2(48.0, 72.0);\n    int center_x = (int)(width / 2);\n    int center_y = (int)(height / 2);\n    printf("small_circle_dia is %d\\n", small_circle_dia);\n    int left_center_x = center_x - (small_circle_dia/2)*cos(rot_ang);\n    printf("center_x is %d\\n", center_x);\n    printf("atan2(48.0, 72.0) is %f\\n", atan2(48.0, 72.0));\n    printf("left_center_x is %d\\n", left_center_x);\n    int left_center_y = center_y - (small_circle_dia/2)*sin(rot_ang);\n    int right_center_x = center_x + (small_circle_dia/2)*cos(rot_ang);\n    int right_center_y = center_y + (small_circle_dia/2)*sin(rot_ang);\n\n    red = gdImageColorAllocate(img, 255, 0, 0);      // Red\n    blue = gdImageColorAllocate(img, 0, 0, 255);     // Blue\n    black = gdImageColorAllocate(img, 0, 0, 0);      // Black\n    grey = gdImageColorAllocate(img, 125, 125, 125); // grey\n    white = gdImageColorAllocate(img, 255, 255, 255); // white\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageRectangle(img, 0, 0, width, height, black);\n\n    // Draw the big circle outline\n    int circle_radius = (int)(height * 2.0 / 5.0);\n    gdImageEllipse(img, center_x, center_y, big_circle_dia, big_circle_dia, black);\n    // left small circle\n    gdImageEllipse(img, left_center_x, left_center_y, small_circle_dia, small_circle_dia, red);\n    // right small circle\n    gdImageEllipse(img, right_center_x, right_center_y, small_circle_dia, small_circle_dia, blue);\n} \n \n \n // https://en.wikipedia.org/wiki/Flag_of_South_Korea\n// https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Function prototype\nvoid draw_korean_flag(gdImagePtr img);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 72:48 = 12:8 = 3:2\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_korean_flag(img);\n\n    FILE *outputFile = fopen("korean_flag_in_gd_w15_step2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_korean_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, blue, black, grey, white;\n    // according to https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n    double scale = width/72;\n    int big_circle_dia = (int)24*scale;\n    int small_circle_dia = (int) big_circle_dia/2;\n    double rot_ang = atan2(48.0, 72.0);\n    int center_x = (int)(width / 2);\n    int center_y = (int)(height / 2);\n    printf("small_circle_dia is %d\\n", small_circle_dia);\n    int left_center_x = center_x - (small_circle_dia/2)*cos(rot_ang);\n    printf("center_x is %d\\n", center_x);\n    printf("atan2(48.0, 72.0) is %f\\n", atan2(48.0, 72.0));\n    printf("left_center_x is %d\\n", left_center_x);\n    int left_center_y = center_y - (small_circle_dia/2)*sin(rot_ang);\n    int right_center_x = center_x + (small_circle_dia/2)*cos(rot_ang);\n    int right_center_y = center_y + (small_circle_dia/2)*sin(rot_ang);\n\n    red = gdImageColorAllocate(img, 255, 0, 0);      // Red\n    blue = gdImageColorAllocate(img, 0, 0, 255);     // Blue\n    black = gdImageColorAllocate(img, 0, 0, 0);      // Black\n    grey = gdImageColorAllocate(img, 125, 125, 125); // grey\n    white = gdImageColorAllocate(img, 255, 255, 255); // white\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageRectangle(img, 0, 0, width, height, black);\n\n    // Draw the big circle outline\n    int circle_radius = (int)(height * 2.0 / 5.0);\n    gdImageEllipse(img, center_x, center_y, big_circle_dia, big_circle_dia, black);\n    // left small circle\n    gdImageEllipse(img, left_center_x, left_center_y, small_circle_dia, small_circle_dia, red);\n    // right small circle\n    gdImageEllipse(img, right_center_x, right_center_y, small_circle_dia, small_circle_dia, blue);\n    gdImageFill(img, left_center_x, left_center_y, red); // Fill left small circle with red\n    gdImageFill(img, right_center_x, right_center_y - small_circle_dia/2-10, red);\n    gdImageFill(img, right_center_x, right_center_y, blue); // Fill right small circle with blue\n    gdImageFill(img, left_center_x, left_center_y + small_circle_dia/2+10, blue);\n    // 用白色蓋掉先前的大圓黑線\n    gdImageEllipse(img, center_x, center_y, big_circle_dia, big_circle_dia, white);\n\n    // 接下來只要改變三個圓的邊框顏色, 並且利用 gdImageFill 對特定區域塗色\n    // 應該就可以完成韓國國旗中間的紅藍區域圖案\n\n    /*\n    // Draw the second circle outline\n    gdImageEllipse(img, center_x + circle_radius / 2, center_y, circle_radius * 2, circle_radius * 2, black);\n\n    // Flood fill the left area with red\n    gdImageFill(img, center_x - circle_radius + 1, center_y, red);\n\n    // Flood fill the right area with blue\n    gdImageFill(img, center_x + circle_radius + 1, center_y, blue);\n\n    // Flood fill the intersection area with yellow\n    gdImageFill(img, center_x, center_y, yellow);\n    */\n} \n \n \n // https://en.wikipedia.org/wiki/Flag_of_South_Korea\n// https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Function prototype\nvoid draw_korean_flag(gdImagePtr img);\n\n// Declare the rotation function\nvoid rotatePoints(int x_orig, int y_orig, double rotation_ang, gdPoint *points, int num_points) {\n    int i;\n    double angle_rad = rotation_ang * M_PI / 180.0;\n\n    for (i = 0; i < num_points; i++) {\n        int x = points[i].x - x_orig;\n        int y = points[i].y - y_orig;\n\n        points[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));\n        points[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));\n    }\n}\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 72:48 = 12:8 = 3:2\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_korean_flag(img);\n\n    FILE *outputFile = fopen("korean_flag_in_gd_w15_step2.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_korean_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, blue, black, grey, white;\n    // according to https://en.wikipedia.org/wiki/Flag_of_South_Korea#/media/File:Flag_of_South_Korea_(construction_sheet).svg\n    double scale = width/72;\n    int big_circle_dia = (int)24*scale;\n    int small_circle_dia = (int) big_circle_dia/2;\n    // left small circle rotated angle is rot_ang\n    double rot_ang = atan2(48.0, 72.0);\n    // rectangle rotated angle is rot_ang2;\n    double rot_ang2 = atan2(72.0, 48.0);\n    double degree = M_PI/180.0;\n    int center_x = (int)(width / 2);\n    int center_y = (int)(height / 2);\n    gdPoint points[4];\n    // for upper rectangle\n    int rect_lower_left_x = center_x - (int)6*scale;\n    int rect_lower_right_x = center_x + (int)6*scale;\n    int rect_upper_left_x = rect_lower_left_x;\n    int rect_upper_right_x = rect_lower_right_x;\n    int rect_lower_left_y = center_y - (int)18*scale;\n    int rect_lower_right_y = rect_lower_left_y;\n    int rect_upper_left_y = rect_lower_left_y - (int)8*scale;\n    int rect_upper_right_y = rect_upper_left_y;\n    // get points\n    points[0].x = rect_lower_left_x;\n    points[0].y = rect_lower_left_y;\n    points[1].x = rect_upper_left_x;\n    points[1].y = rect_upper_left_y;\n    points[2].x = rect_upper_right_x;\n    points[2].y = rect_upper_right_y;\n    points[3].x = rect_lower_right_x;\n    points[3].y = rect_lower_right_y;\n\n    printf("small_circle_dia is %d\\n", small_circle_dia);\n    int left_center_x = center_x - (small_circle_dia/2)*cos(rot_ang);\n    printf("center_x is %d\\n", center_x);\n    printf("atan2(48.0, 72.0) is %f\\n", atan2(48.0, 72.0));\n    printf("left_center_x is %d\\n", left_center_x);\n    int left_center_y = center_y - (small_circle_dia/2)*sin(rot_ang);\n    int right_center_x = center_x + (small_circle_dia/2)*cos(rot_ang);\n    int right_center_y = center_y + (small_circle_dia/2)*sin(rot_ang);\n\n    red = gdImageColorAllocate(img, 255, 0, 0);      // Red\n    blue = gdImageColorAllocate(img, 0, 0, 255);     // Blue\n    black = gdImageColorAllocate(img, 0, 0, 0);      // Black\n    grey = gdImageColorAllocate(img, 125, 125, 125); // grey\n    white = gdImageColorAllocate(img, 255, 255, 255); // white\n\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageRectangle(img, 0, 0, width, height, black);\n\n    // rectangle rotate to upper right\n    rotatePoints(center_x, center_y, rot_ang2/degree, points, 4);\n    gdImageFilledPolygon(img, points, 4, grey);\n    //printf("rot_ang/degree is %f\\n", rot_ang2/degree);\n    // rectangle rotate to upper left\n    rotatePoints(center_x, center_y, -2*rot_ang2/degree, points, 4);\n    gdImageFilledPolygon(img, points, 4, grey);\n    // rectangle rotate to lower ritht\n    rotatePoints(center_x, center_y, - 2*rot_ang/degree, points, 4);\n    gdImageFilledPolygon(img, points, 4, grey);\n    // rectangle rotate to lower left\n    rotatePoints(center_x, center_y, -2*rot_ang2/degree, points, 4);\n    gdImageFilledPolygon(img, points, 4, grey);\n    // Draw upper rectagle four lines\n    /*\n    gdImageLine(img, rect_lower_left_x, rect_lower_left_y, rect_upper_left_x, rect_upper_left_y, grey);\n    gdImageLine(img, rect_lower_right_x, rect_lower_right_y, rect_upper_right_x, rect_upper_right_y, grey);\n    gdImageLine(img, rect_lower_left_x, rect_lower_left_y, rect_lower_right_x, rect_lower_right_y, grey);\n    gdImageLine(img, rect_upper_left_x, rect_upper_left_y, rect_upper_left_x, rect_upper_left_y, grey);\n    */\n    // Draw the big circle outline\n    int circle_radius = (int)(height * 2.0 / 5.0);\n    gdImageEllipse(img, center_x, center_y, big_circle_dia, big_circle_dia, black);\n    // left small circle\n    gdImageEllipse(img, left_center_x, left_center_y, small_circle_dia, small_circle_dia, red);\n    // right small circle\n    gdImageEllipse(img, right_center_x, right_center_y, small_circle_dia, small_circle_dia, blue);\n    gdImageFill(img, left_center_x, left_center_y, red); // Fill left small circle with red\n    gdImageFill(img, right_center_x, right_center_y - small_circle_dia/2-10, red);\n    gdImageFill(img, right_center_x, right_center_y, blue); // Fill right small circle with blue\n    gdImageFill(img, left_center_x, left_center_y + small_circle_dia/2+10, blue);\n    // 用白色蓋掉先前的大圓黑線\n    gdImageEllipse(img, center_x, center_y, big_circle_dia, big_circle_dia, white);\n\n    // 接下來只要改變三個圓的邊框顏色, 並且利用 gdImageFill 對特定區域塗色\n    // 應該就可以完成韓國國旗中間的紅藍區域圖案\n\n    /*\n    // Draw the second circle outline\n    gdImageEllipse(img, center_x + circle_radius / 2, center_y, circle_radius * 2, circle_radius * 2, black);\n\n    // Flood fill the left area with red\n    gdImageFill(img, center_x - circle_radius + 1, center_y, red);\n\n    // Flood fill the right area with blue\n    gdImageFill(img, center_x + circle_radius + 1, center_y, blue);\n\n    // Flood fill the intersection area with yellow\n    gdImageFill(img, center_x, center_y, yellow);\n    */\n} \n \n', 'tags': '', 'url': 'W14.html'}, {'title': 'W15', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Function prototype\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, int rotation);\nvoid draw_proc_flag(gdImagePtr img);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_proc_flag(img);\n\n    FILE *outputFile = fopen("proc_flag_in_gd_w15_outline.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, int rotation) {\n    double deg = M_PI / 180.0;\n    gdPoint points[10]; // Initialize array here\n    int num_points = 10;\n\n    for (int i = 0; i < num_points; i++) {\n        // 若沒有逆時針轉 90 度, 尖角將與水平線平行\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation * deg;\n        int radius = (i % 2 == 0) ? size : size * sin(18 * deg) / cos(36 * deg);\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y - radius * sin(angle);\n    }\n\n    gdImagePolygon(img, points, num_points, color);\n}\n\nvoid draw_proc_flag(gdImagePtr img) {\n    double deg = M_PI / 180.0;\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, yellow, black, white;\n    double angle;\n    // 大黃星位於 width 的 1/6 與 height 的 1/4 處\n    int center_x = (int)(width / 6);\n    int center_y = (int)(height / 4);\n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n    // 大黃星的半徑為 width 的 1/10\n    int big_star_radius = (int)(width / 10);\n    // 小黃星的半徑為 width 的 1/15\n    int small_star_radius = (int)(width / 30);\n    // 先塗上滿地紅\n    red = gdImageColorAllocate(img, 238, 28, 37); // 紅色\n    yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色\n    black = gdImageColorAllocate(img, 0, 0, 0); // 黑色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    // 根據畫布大小塗上白色長方形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    // 畫大黃星\n    draw_star(img, center_x, center_y, big_star_radius, black, 0);\n    // 畫小黃星\n    // draw_star(img, center_x, center_y, small_star_dia, yellow, 0);\n    // the first small star  center_x = (width/3, width/15), angle = atan(5/3)\n    center_x = (int) width/3;\n    center_y = (int) width/15;\n    // 第一個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是 atan(5/3)/deg 的補角\n    angle = 180 - atan(5/3)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, black, angle);\n    // the second small star\n    center_x = (int) 2*width/5;\n    center_y = (int) 2*width/15;\n    // 第二個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是 atan(7/1)/deg 的補角\n    angle = 180 - atan(7/1)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, black, angle);\n    // the third small star\n    center_x = (int) 2*width/5;\n    center_y = (int) 7*width/30;\n    // 第三個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是大小為 atan(7/2)/deg 的角度\n    angle = atan(7/2)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, black, angle);\n    // the fourth small star\n    center_x = (int) width/3;\n    center_y = (int) 3*width/10;\n    // 第四個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是大小為 atan(5/4)/deg 的角度\n    angle = atan(5/4)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, black, angle);\n} \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n// Function prototype\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, int rotation);\nvoid draw_proc_flag(gdImagePtr img);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    // 國旗長寬比為 3:2\n    int height = (int)(width * 2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_proc_flag(img);\n\n    FILE *outputFile = fopen("proc_flag_in_gd_w15.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, int rotation) {\n    double deg = M_PI / 180.0;\n    gdPoint points[10]; // Initialize array here\n    int num_points = 10;\n\n    for (int i = 0; i < num_points; i++) {\n        // 若沒有逆時針轉 90 度, 尖角將與水平線平行\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation * deg;\n        int radius = (i % 2 == 0) ? size : size * sin(18 * deg) / cos(36 * deg);\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y - radius * sin(angle);\n    }\n\n    gdImageFilledPolygon(img, points, num_points, color);\n}\n\nvoid draw_proc_flag(gdImagePtr img) {\n    double deg = M_PI / 180.0;\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, yellow;\n    double angle;\n    // 大黃星位於 width 的 1/6 與 height 的 1/4 處\n    int center_x = (int)(width / 6);\n    int center_y = (int)(height / 4);\n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n    // 大黃星的半徑為 width 的 1/10\n    int big_star_radius = (int)(width / 10);\n    // 小黃星的半徑為 width 的 1/15\n    int small_star_radius = (int)(width / 30);\n    // 先塗上滿地紅\n    red = gdImageColorAllocate(img, 238, 28, 37); // 紅色\n    yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色\n    // 根據畫布大小塗上紅色長方形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    // 畫大黃星\n    draw_star(img, center_x, center_y, big_star_radius, yellow, 0);\n    // 畫小黃星\n    // draw_star(img, center_x, center_y, small_star_dia, yellow, 0);\n    // the first small star  center_x = (width/3, width/15), angle = atan(5/3)\n    center_x = (int) width/3;\n    center_y = (int) width/15;\n    // 第一個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是 atan(5/3)/deg 的補角\n    angle = 180 - atan(5/3)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, yellow, angle);\n    // the second small star\n    center_x = (int) 2*width/5;\n    center_y = (int) 2*width/15;\n    // 第二個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是 atan(7/1)/deg 的補角\n    angle = 180 - atan(7/1)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, yellow, angle);\n    // the third small star\n    center_x = (int) 2*width/5;\n    center_y = (int) 7*width/30;\n    // 第三個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是大小為 atan(7/2)/deg 的角度\n    angle = atan(7/2)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, yellow, angle);\n    // the fourth small star\n    center_x = (int) width/3;\n    center_y = (int) 3*width/10;\n    // 第四個小黃星, 為了尖角從垂直指向大黃星的中心\n    // 必須再逆時針轉以下的 angle, 也就是大小為 atan(5/4)/deg 的角度\n    angle = atan(5/4)/deg;\n    draw_star(img, center_x, center_y, small_star_radius, yellow, angle);\n} \n \n \n \n', 'tags': '', 'url': 'W15.html'}]};